?text()
?rarefy()
rep(c(2005:2010, each=4))
rep(seq(from=2005, to=2010, by=1), each=4))
rep(seq(from=2005, to=2010, by=1), each=4)
rep(seq(from=2005, to=2010, by=1), each=12)
rep(c("J", "F", "M", "A", "M", "J", "J", "A" ,"S", "O", "N", "D", times=6))
rep(c("J", "F", "M", "A", "M", "J", "J", "A" ,"S", "O", "N", "D"), times=6)
?rnorm()
?rgamma()
rgamma(60, shape=2, scale=7)
rangam<-rgamma(72, shape=2, scale=7)
rgamma(72, shape=2, scale=7)
#a. a vector of the years 2005 through 2010 with each year repeated 12 times
year<-rep(seq(from=2005, to=2010, by=1), each=12)
#b. a vector of 12 character strings representing the 12 months of the year (e.g. J, F,M... or Jan, Feb, Mar... etc). Repeat the 12 months once for each year in 4a.
month<-rep(c("J", "F", "M", "A", "M", "J", "J", "A" ,"S", "O", "N", "D"), times=6)
#c. a vector of random numbers the same length as those in 4a) and 4b) sampled from a gamma distribution with shape = 2 and scale = 7.
rangam<-rgamma(72, shape=2, scale=7)
c(10,13,14,31,20,3,9)
c(6,7,90,30,21,7,8)
vec1<-c(10,13,14,31,20,3,9)
vec2<-c(6,7,90,30,21,7,8)
pmin(vec1,vec2)
vec3<-pmin(vec1,vec2)
pmax(vec1,vec2)
sort(vec1, decreasing=TRUE)
set.seed(99)
sample((850:900), size=20, replace=FALSE)
(sample((850:900), size=20, replace=FALSE))
set.seed(99)
(sample((850:900), size=20, replace=FALSE))
set.seed(99)
vec5<-(sample((850:900), size=20, replace=FALSE))
vec5
?range()
range(vec5)
min(vec5)
max(vec5)
sd(vec5)
899-853
order(vec5)
max(order(vec5))-min(order(vec5))
origVec <-seq(from=0, to=12, by=0.2)
origVec
origVec <-seq(from=0, to=2, by=0.2)
origVec
?subset()
Vec1 <-origVec[1:8]
Vec1
Vec2 <-origVec(subset(>=0.4 & <=1))
Vec2 <-origVec(substring(>=0.4 & <=1))
Vec2 <-subset(origVec >=0.4 & <=1)
Vec2 <-subset(origVec, origVec>=0.4 & origVec<=1)
Vec2
Vec3 <-subset(origVec, origVec<0.4 | origVec>1.6)
Vec3
Vec4 <-subset(origVec, origVec<1) <-5
Vec4 <-subset(origVec, origVec<1)
Vec4
Vec4 <-c(origVec, origVec<1) <-5
Vec4 <-[subset(origVec, origVec<1)] <-5
Vec4 <-subset[(origVec, origVec<1)] <-5
?ifelse()
Vec4 <- ifelse(origVec<1, yes=5)
Vec4 <- ifelse(origVec<1, yes=5, no=origVec)
Vec4
Vec5 <-c(54, 67, 89, 90, 34, 12, 22)
Vec5
Vec6 <-c(45, 40, 54, 89, 90, 99)
#b. In what position is the maximum of each vector?
pmax(Vec5, Vec6)
(pmax(Vec5, Vec6))
?pmax()
pmax(Vec5, Vec6)
max <-pmax(Vec5, Vec6)
max
max(Vec5, Vec6)
max <-[max(Vec5, Vec6)]
max <-which(max(Vec5, Vec6))
max <-which(max(Vec5))
max
?identical()
identical(Vec5, Vec6)
ident <-identical(Vec5, Vec6)
ident
Un <-union(Vec5, Vec6)
Un
x <- c(9.45, 8.78, 0.93, 0.47, 0.24, 0.12)
y <- c(10.72, 10.56, 10.35, 10.10, 9.13, 6.72)
z <- c(7.578, 7.456, 6.956, 6.712, 4.832, 3.345)
plot(x, y, col='blue', pch=16, xlab= 'x', ylab='y, z')
points(x, z, col='red', pch=17)
library(plotrix)
axis.break(1,2,style="slash")
?axis.break
x <- c(A, B, C, D, E, F, G, H, I)
y <- c(10.72, 10.56, 10.35, 10.10, 9.13, 6.72)
z <- c(7.578, 7.456, 6.956, 6.712, 4.832, 3.345)
plot(x, y, col='blue', pch=16, xlab= 'x', ylab='Number of OTUs')
points(x, z, col='red', pch=17)
library(plotrix)
axis.break(2,2,style="slash")
x <- c("A", "B", "C", "D", "E", "F", "G", "H", "I")
y <- c(10.72, 10.56, 10.35, 10.10, 9.13, 6.72)
z <- c(7.578, 7.456, 6.956, 6.712, 4.832, 3.345)
plot(x, y, col='blue', pch=16, xlab= 'x', ylab='Number of OTUs')
points(x, z, col='red', pch=17)
library(plotrix)
axis.break(2,2,style="slash")
x <- c("A", "B", "C", "D", "E", "F", "G", "H", "I")
y <- c(74, 29, 420, 39, 14, 50, 9, 12, 4)
plot(x, y, col='blue', pch=16, xlab= 'x', ylab='Number of OTUs')
points(x, y, col='red', pch=17)
library(plotrix)
axis.break(2,2,style="slash")
x <- c("A", "B", "C", "D", "E", "F", "G", "H", "I")
y <- c(74, 29, 420, 39, 14, 50, 9, 12, 4)
plot(x, y, ylin=450, col='blue', pch=16, xlab= 'x', ylab='Number of OTUs')
points(x, y, col='red', pch=17)
library(plotrix)
axis.break(2,2,style="slash")
x <- c("A", "B", "C", "D", "E", "F", "G", "H", "I")
y <- c(74, 29, 420, 39, 14, 50, 9, 12, 4)
plot(x, y, ylim=450, xlim=10 col='blue', pch=16, xlab= 'x', ylab='Number of OTUs')
points(x, y, col='red', pch=17)
library(plotrix)
axis.break(2,2,style="slash")
x <- c("A", "B", "C", "D", "E", "F", "G", "H", "I")
y <- c(74, 29, 420, 39, 14, 50, 9, 12, 4)
plot(x, y, ylim=450, xlim=10, col='blue', pch=16, xlab= 'x', ylab='Number of OTUs')
points(x, y, col='red', pch=17)
library(plotrix)
axis.break(2,2,style="slash")
x <- c("A", "B", "C", "D", "E", "F", "G", "H", "I")
y <- c(74, 29, 420, 39, 14, 50, 9, 12, 4)
plot(x, y, ylim=450, col='blue', pch=16, xlab= 'x', ylab='Number of OTUs')
points(x, y, col='red', pch=17)
library(plotrix)
axis.break(2,2,style="slash")
?ylim
?plot
library(ggplot2)
?geom_bar
y <- c(74, 29, 420, 39, 14, 50, 9, 12, 4)
geom_bar(y)
?aes
Sample <- c(1,2,3,4,5)
Scepter <- c(190000, 320000, 520000, 380000, 1100000)
Hemo <- c(185000, 300000, 450000, 450000, 950000)
comparision <- cbind(Sample, Scepter, Hemo)
View(comparision)
Sample <- c("Scepter", "Scepter", "Scepter", "Scepter", "Scepter", "Hemo","Hemo","Hemo","Hemo","Hemo")
Count <- c(190000, 320000, 520000, 380000, 1100000,185000, 300000, 450000, 450000, 950000)
comparision <- cbind(Sample, Count)
View(comparision)
t.test(Count ~Sample, daat=comparison)
Sample <- c("Scepter", "Scepter", "Scepter", "Scepter", "Scepter", "Hemo","Hemo","Hemo","Hemo","Hemo")
Count <- c(190000, 320000, 520000, 380000, 1100000,185000, 300000, 450000, 450000, 950000)
comparison <- cbind(Sample, Count)
t.test(Count ~Sample, daat=comparison)
bartlett.test(Count ~Sample, daat=comparison) #Bartlett's test for the HO that there is no differences in the variances, ie homogeneity of variance
Sample <- c("Scepter", "Scepter", "Scepter", "Scepter", "Scepter", "Hemo","Hemo","Hemo","Hemo","Hemo")
Count <- c(190000, 320000, 520000, 380000, 1100000,185000, 300000, 450000, 450000, 950000)
comparison <- cbind(Sample, Count)
t.test(Count ~Sample, data=comparison)
bartlett.test(Count ~Sample, data=comparison) #Bartlett's test for the HO that there is no differences in the variances, ie homogeneity of variance
Sample <- c("Scepter", "Scepter", "Scepter", "Scepter", "Scepter", "Hemo","Hemo","Hemo","Hemo","Hemo")
Count <- c(190000, 320000, 520000, 380000, 1100000,185000, 300000, 450000, 450000, 950000)
comparison <- cbind(Sample, Count)
t.test(Count ~Sample, data=comparison)
bartlett.test(Count ~Sample, data=comparison) #Bartlett's test for the HO that there is no differences in the variances, ie homogeneity of variance
t.test(Count ~Sample, daat=comparison)
t.test(Count ~Sample, data=comparison)
?t.test
t.test(Count ~Sample, data=comparison, paired = FALSE)
t.test(Count ~Sample, data=comparison, var.equal=TRUE)
t.test(Count ~Sample, data=comparison, var.equal=TRUE, paired=FALSE)
install.packages("swirl")
rm(list=ls())
library(swirl)
swirl()
citation()
#Title: Transcriptomic SNP Calling
#Author: HM Putnam
#Date Last Modified: 20160921
#See Readme file for details
rm(list=ls()) #clears workspace
#Read in required libraries
##### Include Versions of libraries
#Required Data files
# Set Working Directory:
setwd("/Users/hputnam/Workshops/Con_Genomics/Conservation-Gene-Expression/SNPcalling_tutorial/") #set working
snps<-read.delim('ahy_snps.012',header=F,na=-1,row.names=1)
pos<-read.delim('ahy_snps.012.pos',header=F)
indv<-read.delim('ahy_snps.012.indv',header=F)
colnames(snps)<-paste(pos[,1],pos[,2],sep=':')
rownames(snps)<-indv[,1]
snps<-as.matrix(snps)
#read in meta data
meta<-read.delim('meta.txt')
#read in meta data
meta<-read.delim('meta.txt')
pc.out<-prcomp(snps)
summary(pc.out)
plot(pc.out$x[,1],pc.out$x[,2],col=meta$Pool,xlab='PC1',ylab='PC2',pch=19)
legend('topright',legend=unique(meta$Pool),fill=c('black','red','green'))
install.packages('hierfstat')
library(hierfstat)
#FST Outlier
#prepare 0,1,2 matrix in hierfstat format
#we use our pca to separate samples into clusters to test for genetic differentiation
hf<-snps
hf[hf==0]<-11
hf[hf==1]<-12
hf[hf==2]<-22
pop=as.numeric(pc.out$x[,1]>2)+1
hf<-as.data.frame(cbind(pop,snps))
#calculate Weir-Cockerham Fst
fst.out<-wc(hf)
#global estimate
fst.out$FST
#look at fst distribution across sites
site.fst<-fst.out$per.loc[['FST']]
hist(site.fst,xlab='Fst',ylab='Counts',main='Distribution of Fst between PC1 clusters',col='grey')
#Title: PGA Respirometry Data
#Author: HM Putnam
#Date Last Modified: 20160920
#See Readme file for details
rm(list=ls()) #clears workspace
#Read in required libraries
##### Include Versions of libraries
#library('plyr')
#library('ggplot2')
#library("sciplot")
library("segmented")
#Required Data files
# Set Working Directory:
setwd("/Users/hputnam/MyProjects/Mcap_PGA_TGA/RAnalysis/Data") #set working
mainDir<-"/Users/hputnam/MyProjects/Mcap_PGA_TGA/RAnalysis/" #set main directory
# # load data
# respData <- read.csv(text=paste0(head(readLines("/Users/hputnam/MyProjects/Mcap_PGA_TGA/RAnalysis/Data/Respirometry/20160811_A67.csv"), -4), collapse="\n"))
# #subset the data to only columns of interest
# respData <- respData[,c(1,2,7,9,16,20)]
# #plot the data
# plot(Value~delta_t, pch=16, cex=0.5, data=respData)
# #source("/Users/hputnam/MyProjects/Mcap_PGA_TGA/RAnalysis/Scripts/outlier_removal.R")
# #outlierKD(respData, Value)
# #plot the data
# #plot(Value~delta_t, pch=16, cex=0.5, data=respData)
# #find the max to indicate break point
# respData$delta_t[which.max(respData$Value)]
# #identify the linear model
# lin.mod <- lm(Value~delta_t, data=respData)
# #identify the break points for the sigmented model
# segmented.mod <- segmented(lin.mod, seg.Z = ~delta_t, psi=(respData$delta_t[which.max(respData$Value)]))
# #plot the data
# plot(Value~delta_t, pch=16, cex=0.5, data=respData)
# #plot the model lines
# plot(segmented.mod, add=T, color="red")
# #report slopes
# summary(segmented.mod)
# #extract slopes
# segmented.mod[1]
### Need to remove outliers and large breaks/gaps
#if value is ± x from line equation for each segement remove it
# set working directory to where the data is
setwd(file.path(mainDir, 'Data/Respirometry'))
path<-"/Users/hputnam/MyProjects/Mcap_PGA_TGA/RAnalysis/Data/Respirometry" #the location of all your respirometry files
#find all the data files
file.names<-list.files(path=path) #list all the file names in your data and sample directory
file.names <- file.names[grep("[.]csv", file.names)] # select only the csv files
#create an empty dataframe to put the Slope values in
nrow<-length(file.names) #set number of rows to the number of samples
Slopes <- matrix(nrow = nrow, ncol = 3) #set the dimensions of the dataframe
rownames(Slopes)<-file.names #identify row names
colnames(Slopes)<-c('Sample.ID','Photo','Resp') #identify column names
#run a for loop to bring in the respirometry files one at a time and calculate 2 slopes per file
for(i in 1: length(file.names)) {
Data<-read.csv(text=paste0(head(readLines(file.names[i]), -4), collapse="\n"), header=T, sep=",", na.string="NA",as.is=T)
Data<-Data[,c(1,2,7,9,16,20)] #remove unnecessary columns
#name of the file without .csv
name<-unlist(strsplit(file.names[i], split='.', fixed=TRUE))[1]
#find the max to indicate break point
#Data$delta_t[which.max(Data$Value)]
#identify the linear model
lin.mod <- lm(Value~delta_t, data=Data)
#identify the break points for the sigmented model
segmented.mod <- segmented(lin.mod, seg.Z = ~delta_t, psi=(Data$delta_t[which.max(Data$Value)]))
#Calculate Slopes
Slopes[i,1]<-name #add sample name to data output
Slopes[i,2]<-segmented.mod$coefficients[2] #add slope1
Slopes[i,3]<-segmented.mod$coefficients[3] #add slope2
}
#output in µmol per liter oxygen per min
Slopes <- data.frame(Slopes)
class(Slopes)
for(i in 1: length(file.names)) {
plot(Value~delta_t, pch=16, cex=0.5, data=Data)
}
plot(Value~delta_t, pch=16, cex=0.5, data=Data)
plot(Value~delta_t, pch=16, cex=0.5, data=Data)
file.names
?par
?mfrow
par(mfrow=c(4,5))
for(i in 1: length(file.names)) {
plot(Value~delta_t, pch=16, cex=0.5, data=Data)
}
par(mfrow=c(4,5))
par(mar=c(0,1,1,1))
for(i in 1: length(file.names)) {
plot(Value~delta_t, pch=16, cex=0.5, data=Data)
}
par(mfrow=c(4,5))
par(mar=c(0,1,1,1))
for(i in 1: length(file.names)) {
Data<-read.csv(text=paste0(head(readLines(file.names[i]), -4), collapse="\n"), header=T, sep=",", na.string="NA",as.is=T)
plot(Value~delta_t, pch=16, cex=0.5, data=Data)
}
plot(Value~delta_t, pch=16, cex=0.5, data=Data)
plot(Slopes, add=T, color="red")
#Title: PGA Respirometry Data
#Author: HM Putnam
#Date Last Modified: 20160920
#See Readme file for details
rm(list=ls()) #clears workspace
#Read in required libraries
##### Include Versions of libraries
#library('plyr')
#library('ggplot2')
#library("sciplot")
library("segmented")
#Required Data files
# Set Working Directory:
setwd("/Users/hputnam/MyProjects/Mcap_PGA_TGA/RAnalysis/Data") #set working
mainDir<-"/Users/hputnam/MyProjects/Mcap_PGA_TGA/RAnalysis/" #set main directory
# load data
respData <- read.csv(text=paste0(head(readLines("/Users/hputnam/MyProjects/Mcap_PGA_TGA/RAnalysis/Data/Respirometry/20160811_A67.csv"), -4), collapse="\n"))
#subset the data to only columns of interest
respData <- respData[,c(1,2,7,9,16,20)]
#plot the data
plot(Value~delta_t, pch=16, cex=0.5, data=respData)
#source("/Users/hputnam/MyProjects/Mcap_PGA_TGA/RAnalysis/Scripts/outlier_removal.R")
#outlierKD(respData, Value)
#plot the data
#plot(Value~delta_t, pch=16, cex=0.5, data=respData)
#find the max to indicate break point
respData$delta_t[which.max(respData$Value)]
#identify the linear model
lin.mod <- lm(Value~delta_t, data=respData)
#identify the break points for the sigmented model
segmented.mod <- segmented(lin.mod, seg.Z = ~delta_t, psi=(respData$delta_t[which.max(respData$Value)]))
#plot the data
plot(Value~delta_t, pch=16, cex=0.5, data=respData)
plot(segmented.mod, add=T, color="red")
segmented.mod
segmented.mod[1]
div.oeef
div.off()
dev.off()
plot(Value~delta_t, pch=16, cex=0.5, data=respData)
#plot the model lines
plot(segmented.mod$coefficients[2], add=T, color="red")
plot(Value~delta_t, pch=16, cex=0.5, data=respData)
segmented.mod$coefficients[2]
segmented.mod
plot(segmented.mod, add=T, color="red")
segmented.mod
summary(segmented.mod)
segmented.mod[1]
plot(segmented.mod[1], add=T, color="red")
segmented.mod[1]
segmented.mod$coefficients[2]
segmented.mod$coefficients[3]
segmented.mod$coefficients[1]
plot(segmented.mod+, add=T, color="red")
plot(Value~delta_t, pch=16, cex=0.5, data=respData)
#plot the model lines
plot(segmented.mod, add=T, color="red")
#Title: PGA Respirometry Data
#Author: HM Putnam
#Date Last Modified: 20160920
#See Readme file for details
rm(list=ls()) #clears workspace
#Read in required libraries
##### Include Versions of libraries
#library('plyr')
#library('ggplot2')
#library("sciplot")
library("segmented")
#Required Data files
# Set Working Directory:
setwd("/Users/hputnam/MyProjects/Mcap_PGA_TGA/RAnalysis/Data") #set working
mainDir<-"/Users/hputnam/MyProjects/Mcap_PGA_TGA/RAnalysis/" #set main directory
# # load data
# respData <- read.csv(text=paste0(head(readLines("/Users/hputnam/MyProjects/Mcap_PGA_TGA/RAnalysis/Data/Respirometry/20160811_A67.csv"), -4), collapse="\n"))
# #subset the data to only columns of interest
# respData <- respData[,c(1,2,7,9,16,20)]
# #plot the data
# plot(Value~delta_t, pch=16, cex=0.5, data=respData)
# #source("/Users/hputnam/MyProjects/Mcap_PGA_TGA/RAnalysis/Scripts/outlier_removal.R")
# #outlierKD(respData, Value)
# #plot the data
# #plot(Value~delta_t, pch=16, cex=0.5, data=respData)
# #find the max to indicate break point
# respData$delta_t[which.max(respData$Value)]
# #identify the linear model
# lin.mod <- lm(Value~delta_t, data=respData)
# #identify the break points for the sigmented model
# segmented.mod <- segmented(lin.mod, seg.Z = ~delta_t, psi=(respData$delta_t[which.max(respData$Value)]))
# #plot the data
# plot(Value~delta_t, pch=16, cex=0.5, data=respData)
# #plot the model lines
# plot(segmented.mod, add=T, color="red")
# #report slopes
# summary(segmented.mod)
# #extract slopes
# segmented.mod[1]
### Need to remo
# set working directory to where the data is
setwd(file.path(mainDir, 'Data/Respirometry'))
path<-"/Users/hputnam/MyProjects/Mcap_PGA_TGA/RAnalysis/Data/Respirometry" #the location of all your respirometry files
#find all the data files
file.names<-list.files(path=path) #list all the file names in your data and sample directory
file.names <- file.names[grep("[.]csv", file.names)] # select only the csv files
#create an empty dataframe to put the Slope values in
nrow<-length(file.names) #set number of rows to the number of samples
Slopes <- matrix(nrow = nrow, ncol = 3) #set the dimensions of the dataframe
rownames(Slopes)<-file.names #identify row names
colnames(Slopes)<-c('Sample.ID','Photo','Resp') #identify column names
#run a for loop to bring in the respirometry files one at a time and calculate 2 slopes per file
for(i in 1: length(file.names)) {
Data<-read.csv(text=paste0(head(readLines(file.names[i]), -4), collapse="\n"), header=T, sep=",", na.string="NA",as.is=T)
Data<-Data[,c(1,2,7,9,16,20)] #remove unnecessary columns
#name of the file without .csv
name<-unlist(strsplit(file.names[i], split='.', fixed=TRUE))[1]
#find the max to indicate break point
#Data$delta_t[which.max(Data$Value)]
#identify the linear model
lin.mod <- lm(Value~delta_t, data=Data)
#identify the break points for the sigmented model
segmented.mod <- segmented(lin.mod, seg.Z = ~delta_t, psi=(Data$delta_t[which.max(Data$Value)]))
#Calculate Slopes
Slopes[i,1]<-name #add sample name to data output
Slopes[i,2]<-segmented.mod$coefficients[2] #add slope1
Slopes[i,3]<-segmented.mod$coefficients[3] #add slope2
}
segmented.mod
#Title: PGA Respirometry Data
#Author: HM Putnam
#Date Last Modified: 20160920
#See Readme file for details
rm(list=ls()) #clears workspace
#Read in required libraries
##### Include Versions of libraries
#library('plyr')
#library('ggplot2')
#library("sciplot")
library("segmented")
#Required Data files
# Set Working Directory:
setwd("/Users/hputnam/MyProjects/Mcap_PGA_TGA/RAnalysis/Data") #set working
mainDir<-"/Users/hputnam/MyProjects/Mcap_PGA_TGA/RAnalysis/" #set main directory
# set working directory to where the data is
setwd(file.path(mainDir, 'Data/Respirometry'))
path<-"/Users/hputnam/MyProjects/Mcap_PGA_TGA/RAnalysis/Data/Respirometry" #the location of all your respirometry files
#find all the data files
file.names<-list.files(path=path) #list all the file names in your data and sample directory
file.names <- file.names[grep("[.]csv", file.names)] # select only the csv files
#create an empty dataframe to put the Slope values in
nrow<-length(file.names) #set number of rows to the number of samples
Slopes <- matrix(nrow = nrow, ncol = 4) #set the dimensions of the dataframe
rownames(Slopes)<-file.names #identify row names
colnames(Slopes)<-c('Sample.ID','Photo','Resp','Eqs') #identify column names
#run a for loop to bring in the respirometry files one at a time and calculate 2 slopes per file
for(i in 1: length(file.names)) {
Data<-read.csv(text=paste0(head(readLines(file.names[i]), -4), collapse="\n"), header=T, sep=",", na.string="NA",as.is=T)
Data<-Data[,c(1,2,7,9,16,20)] #remove unnecessary columns
#name of the file without .csv
name<-unlist(strsplit(file.names[i], split='.', fixed=TRUE))[1]
#find the max to indicate break point
#Data$delta_t[which.max(Data$Value)]
#identify the linear model
lin.mod <- lm(Value~delta_t, data=Data)
#identify the break points for the sigmented model
segmented.mod <- segmented(lin.mod, seg.Z = ~delta_t, psi=(Data$delta_t[which.max(Data$Value)]))
#Calculate Slopes
Slopes[i,1]<-name #add sample name to data output
Slopes[i,2]<-segmented.mod$coefficients[2] #add slope1
Slopes[i,3]<-segmented.mod$coefficients[3] #add slope2
Slopes[i,4]<-segmented.mod #add slope2
}
#run a for loop to bring in the respirometry files one at a time and calculate 2 slopes per file
for(i in 1: length(file.names)) {
Data<-read.csv(text=paste0(head(readLines(file.names[i]), -4), collapse="\n"), header=T, sep=",", na.string="NA",as.is=T)
Data<-Data[,c(1,2,7,9,16,20)] #remove unnecessary columns
#name of the file without .csv
name<-unlist(strsplit(file.names[i], split='.', fixed=TRUE))[1]
#find the max to indicate break point
#Data$delta_t[which.max(Data$Value)]
#identify the linear model
lin.mod <- lm(Value~delta_t, data=Data)
#identify the break points for the sigmented model
segmented.mod <- segmented(lin.mod, seg.Z = ~delta_t, psi=(Data$delta_t[which.max(Data$Value)]))
#Calculate Slopes
Slopes[i,1]<-name #add sample name to data output
Slopes[i,2]<-segmented.mod$coefficients[2] #add slope1
Slopes[i,3]<-segmented.mod$coefficients[3] #add slope2
Eqs<-segmented.mod #add slope2
}
Eqs
